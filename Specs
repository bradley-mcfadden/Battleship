COSC2947 E "Object Oriented Programming Using C++"
-------------------------------------------------
Programming Project
===================


Task
----

Develop a program to play the game BattleShip (http:
//en.wikipedia.org/wiki/Battleship_(game))
on a computer. The design of the program shall make it 
possible to implement computer players
of different strength. However only one (very simple)
player is required for the project.


Implementation
--------------

The program uses several classes. Each class should have 
its own source code and header file.
Equip the header files with include guards. The following 
types, classes and functions should be
implemented.


EnemyPiece
=--------=
EnemyPiece is an enumeration type that represents the 
possible contents of a square on the
board. A possible definition is

enum class EnemyPiece {HIT, MISS, EMPTY};


EnemyPiece can be defined in the header file of the Board 
class.


PlayerPiece
=---------=
PlayerPiece is an enumeration type that represents the 
possible contents of a square on the board.

A possible definition is

enum class PlayerPiece {AIRCRAFT, BATTLESHIP, CRUISER, 
SUBMARINE, PATROL, EMPTY};

PlayerPiece can be defined in the header file of the Board 
class.


Move
=--=
The program represents moves by a character and an integer. 
These combine to form the index of the square where the new 
piece is placed in the board array. Move is therefore a 
typedef that defines Move as an appropriate struct type.


Board
=---=
The Board class represents the current state of the board. 
It contains two one-dimensional arrays of size 100 (10x10) 
of the board squares, one for each players’s pieces (both 
are PlayerPiece). It also contains two one-dimensional 
arrays of size 100 (10x10) of EnemyPiece which are used for
display purposes. It provides the following member functions:

Board(): Default constructor that initializes the board by 
calling the member function reset().

void reset() noexcept: Erases all ships and shot markers 
from their respective boards.

void display(int player) const noexcept: If player is 1, 
then display player one’s current board of PlayerPiece, and 
player two’s current board of EnemyPiece. If player is 2,
then display the opposite boards.

EnemyPiece makeMove(const Move &): Executes the move 
indicated by the function parameter, and updates the 
boards accordingly.

bool isLegal(const Move &) const noexcept: Checks whether 
it is legal to attack the specified location.


Player
=----=
Player is an abstract base class for the common functionality 
of human and computer players. It stores the name of the player, 
and an instance of the Board class belonging to the player. The
interface contains the following member functions:

Player(const string&): The constructor of the Player class 
receives the name of the player.

Move makeMove(const Board &): This is a pure virtual function 
that gets the players move.

Player has no default constructor.


HumanPlayer
=---------=
This class is derived from the class Player. The member function 
makeMove(const Board&) prompts the user for the location where 
they want to launch their attack. This function should
loop until the user enters a valid move, per the 
Board::isLegal function.


ComputerPlayer
=------------=
This class is an abstract base class derived from the class 
Player. The class implements common functionality for all 
computer player classes. It does not implement the 
makeMove(constBoard &) member function. The class ensures that 
different computer players get different names assigned. The 
first computer player is named Computer A, the second computer 
player is named Computer B, etc. In order to create the names 
the class uses a static variable of type char that is increased 
every time that an instance of ComputerPlayer is created. If 
the char passes the ‘Z’ character, it should go back to ‘A’. 
The interface of the class only has one member:

ComputerPlayer::ComputerPlayer(): The initializer generates the 
player's name and passes it to the base class constructor.


RandomPlayer
------------
This class implements a very simple computer player. Its 
implementation of the makeMove(const Board &) member function 
makes random (but legal) moves. Like all computer player 
classes RandomPlayer inherits from ComputerPlayer. The random 
generator should use a mersenne twister, available in <random>,
seeded with the current time.


Game
-----
The Game class controls the flow of a game. It contains two 
Pointers to Player objects as member variables, and a Board 
object. The class provides the following member functions:

Game::Game(): The default constructor initializes an empty 
board and sets the player pointers to nullptr.

Game::~Game(): The destructor deallocates any dynamically 
allocated objects.

void selectPlayers(): Prompts the user for each of the two 
players for the type(human/computer) of the player. For a 
human player the function also asks for the player's name.
The function then creates the objects for the players 
dynamically.

Player* nextPlayer() const: The function returns the 
pointer to the player whose move it is.

void play(): While isRunning returns true, the function 
displays the current player’s boards and invokes the makeMove 
member function of the player whose move it is. The
function then passes the result of the player’s makeMove 
function to the Board’s makeMove, and displays to the user 
an appropriate message of whether or not they hit an enemy 
vessel.

void announceWinner(): Announces the end of the game and 
the name of the winner.

bool isRunning(): returns true if neither player has yet won


main()
------
The main function of the program creates a Game object and 
then calls its member functions selectPlayers(), play() and 
announceWinner(). Place this function in its own file.


Due Date
--------
The project is due on Tuesday, December 3, 2019 at 23:59 pm.
Late submissions will be penalized by 20% per day up to a 
maximum of one day!


Submission and Grading
----------------------
The programming projects can be solved using any standard
-conforming C++ compiler on any operating system. The 
solutions shall adhere to the C++ ISO-standard and must be 
submitted in source form only, i.e. as *.cpp and *.h or 
*.hpp files. Do not submit any executables or object code. 
In order to facilitate grading, the code should be 
formatted in an easily readable manner and should contain 
sufficient documentation (comments), including the name 
and student number of the submitter.

The solutions must be submitted to D2L. Do not paste the 
source code into the comment box. Only compress to "zip". 
Do not compress to “7z” or "rar" or any other type. No files
except source code (*.cpp) and header (*.h, *.hpp) 
files will be considered.

The solutions will be graded according to the following 
three factors:
1. Program functionality
2. Quality of implementation
3. Documentation, formatting, and readability

Programs must compile without errors.
